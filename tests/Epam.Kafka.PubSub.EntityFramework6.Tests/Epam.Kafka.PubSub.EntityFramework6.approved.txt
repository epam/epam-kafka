namespace Epam.Kafka.PubSub.EntityFramework6
{
    public static class ServiceCollectionExtensions
    {
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection TryAddKafkaDbContextState<TContext>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TContext : System.Data.Entity.DbContext, Epam.Kafka.PubSub.EntityFramework6.Subscription.State.IKafkaStateDbContext { }
    }
}
namespace Epam.Kafka.PubSub.EntityFramework6.Subscription
{
    public abstract class DbContextEntitySubscriptionHandler<TKey, TValue, TContext, TEntity> : Epam.Kafka.PubSub.EntityFramework6.Subscription.DbContextSubscriptionHandler<TKey, TValue, TContext>
        where TKey :  notnull
        where TContext : System.Data.Entity.DbContext
        where TEntity :  class
    {
        protected DbContextEntitySubscriptionHandler(TContext context, Microsoft.Extensions.Logging.ILogger logger) { }
        protected System.Data.Entity.DbSet<TEntity> Set { get; }
        protected override sealed object? FindLocal(Confluent.Kafka.ConsumeResult<TKey, TValue> value) { }
        protected abstract TEntity? FindLocal(System.Data.Entity.DbSet<TEntity> dbSet, Confluent.Kafka.ConsumeResult<TKey, TValue> value);
        protected override sealed void LoadEntitiesChunk(System.Collections.Generic.IReadOnlyCollection<Confluent.Kafka.ConsumeResult<TKey, TValue>> chunk) { }
        protected abstract void LoadMainChunk(System.Linq.IQueryable<TEntity> queryable, System.Collections.Generic.IReadOnlyCollection<Confluent.Kafka.ConsumeResult<TKey, TValue>> chunk);
        protected virtual void LoadRelatedChunk(System.Collections.Generic.IReadOnlyCollection<Confluent.Kafka.ConsumeResult<TKey, TValue>> chunk) { }
        protected abstract bool TryCreate(Confluent.Kafka.ConsumeResult<TKey, TValue> value, out TEntity? entity);
        protected override sealed bool TryCreate(Confluent.Kafka.ConsumeResult<TKey, TValue> value, out object? entity) { }
        protected override sealed string? Update(Confluent.Kafka.ConsumeResult<TKey, TValue> value, object entity, bool created) { }
        protected abstract string? Update(Confluent.Kafka.ConsumeResult<TKey, TValue> value, TEntity entity, bool created);
    }
    public abstract class DbContextSubscriptionHandler<TKey, TValue, TContext> : Epam.Kafka.PubSub.Subscription.SubscriptionHandler<TKey, TValue>
        where TKey :  notnull
        where TContext : System.Data.Entity.DbContext
    {
        protected DbContextSubscriptionHandler(TContext context, Microsoft.Extensions.Logging.ILogger logger) { }
        protected int ChunkSize { get; set; }
        protected TContext Context { get; }
        protected abstract object? FindLocal(Confluent.Kafka.ConsumeResult<TKey, TValue> value);
        protected abstract bool IsDeleted(Confluent.Kafka.ConsumeResult<TKey, TValue> value);
        protected abstract void LoadEntitiesChunk(System.Collections.Generic.IReadOnlyCollection<Confluent.Kafka.ConsumeResult<TKey, TValue>> chunk);
        protected override void ProcessBatch(System.Collections.Generic.IDictionary<Confluent.Kafka.ConsumeResult<TKey, TValue>, string?> items, System.Threading.CancellationToken cancellationToken) { }
        protected override string ProcessSingle(Confluent.Kafka.ConsumeResult<TKey, TValue> item) { }
        protected virtual void SaveChanges() { }
        protected abstract bool TryCreate(Confluent.Kafka.ConsumeResult<TKey, TValue> value, out object? entity);
        protected abstract string? Update(Confluent.Kafka.ConsumeResult<TKey, TValue> value, object entity, bool created);
    }
}
namespace Epam.Kafka.PubSub.EntityFramework6.Subscription.State
{
    public interface IKafkaStateDbContext
    {
        System.Data.Entity.DbSet<Epam.Kafka.PubSub.EntityFramework6.Subscription.State.KafkaTopicState> KafkaTopicStates { get; }
    }
    public class KafkaTopicState
    {
        public KafkaTopicState() { }
        [System.ComponentModel.DataAnnotations.Required]
        public string ConsumerGroup { get; set; }
        [System.ComponentModel.DataAnnotations.ConcurrencyCheck]
        [System.ComponentModel.DataAnnotations.Required]
        public long Offset { get; set; }
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        [System.ComponentModel.DataAnnotations.Required]
        public int Partition { get; set; }
        [System.ComponentModel.DataAnnotations.Required]
        public bool Pause { get; set; }
        public System.DateTimeOffset Timestamp { get; set; }
        [System.ComponentModel.DataAnnotations.Required]
        public string? Topic { get; set; }
    }
    public static class KafkaTopicStateExtensions
    {
        public static System.Data.Entity.ModelConfiguration.EntityTypeConfiguration<Epam.Kafka.PubSub.EntityFramework6.Subscription.State.KafkaTopicState> AddKafkaState(this System.Data.Entity.DbModelBuilder builder) { }
    }
}
